:canonical-base-url: https://dckms.github.io/system-architecture

.. index::
   single: Aggregate; in Golang
   :name: emacsway-aggregate-golang

======================
Поиск границ Агрегатов
======================

.. sectionauthor:: Ivan Zakrevsky

.. contents:: Содержание


Бизнес-требования
=================

Бизнес-требования к Reference Application описаны в разделе "`4.6. Система квалификационной классификации членов Организации <https://github.com/ru-arc/charter/blob/main/charter.md#46-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%BA%D0%B2%D0%B0%D0%BB%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-%D1%87%D0%BB%D0%B5%D0%BD%D0%BE%D0%B2-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8>`__" Устава региональной общественной организации "Объединение ИТ-Архитекторов".

Выделим основные из них:

#. Каждый член Организации может отдать 20 рекомендаций (признаний) в год в пользу других членов.
#. Одна рекомендация от члена Организации претендуемого (или более высокого) квалификационного класса равноценна двум рекомендациям от членов Организации текущего квалификационного класса (излишки не переносятся).
#. Рекомендации от членов Организации более низкого квалификационного класса не допускаются.
#. Допускается одна рекомендация рекомендующего за один конкретный артефакт рекомендуемого.
#. Требуемые количества рекомендаций по квалификационным классам:

   1) Эксперт - 20 рекомендаций Экспертов или 40 рекомендаций Кандидатов в эксперты;
   2) Кандидат в эксперты - 10 рекомендаций Кандидатов в эксперты или 20 рекомендаций 1-го класса;
   3) 1 класс - 7 рекомендаций 1-го класса или 14 рекомендаций 2-го класса;
   4) 2 класс - 5 рекомендаций 2-го класса или 10 рекомендаций 3-го класса;
   5) 3 класс - 3 рекомендации 3-го класса или 6 рекомендаций без класса;
   6) без класса - по умолчанию.

Остальные требования в настоящий момент рассмотрения нерелевантны.


Strong Consistency (RDBMS)
==========================

Этот вариант реализации хорошо был расcмотрен в статье "`Modeling Relationships in a DDD Way <https://enterprisecraftsmanship.com/posts/modeling-relationships-in-ddd-way/>`__" by Vladimir Khorikov, поэтому подробно рассматривать мы его не будем.
Приведу только заключительный фрагмент его статьи:

.. literalinclude:: _media/aggregate-boundaries/m2m.cs
   :caption: `Example from Stackoverflow <https://stackoverflow.com/questions/24921227/save-and-load-objects-without-breaking-encapsulation>`__
   :language: csharp




Eventual Consistency
====================

Первоначальная модель
---------------------

Хотя предполагается использование RDBMS, но была предпринята попытка найти такие контуры Агрегатов, которые без существенной переработки могли бы функционировать и в условиях отсутствия транзакционной согласованности.

Самый первый вариант модели практически полностью воспроизводил структуру (online) excel-таблиц, использовавшихся на тот момент.
Упрощенная реализация модели выглядела примерно так:


Упрощенная реализация первоначальной модели
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. literalinclude:: _media/aggregate-boundaries/aggregate_boundaries_1.go
   :language: go

Метод ``Recognizer.Endorse(Endorsed, ArtifactDescription, time.Time)`` является фабричным методом Агрегата ``Endorsement``.
При сохранении Агрегата ``Endorsement``, из него извлекаются Доменные События, и отправляются подписчикам через какой-то механизм доставки.
Мы предполагаем, что они могут быть обработаны как синхронно в той же транзакции (Mediator/Observer Design Pattern), так и асинхронно (`Message Broker <https://www.enterpriseintegrationpatterns.com/MessageBroker.html>`__) в другой транзакции.

На это Доменное Событие ``EndorsementCreated`` подписаны:

1. ``Recognizer``, у которого вызывается метод ``Recognizer.DecreaseAvailableEndorsementCount()`` для вычитания использованной рекомендации из счетчика доступных в этом году рекомендаций;
2. ``Endorse``, у которого вызывается метод ``Endorsed.IncreaseReceivedEndorsementCount(Weight)`` с указанием веса рекомендации, зависящего от отношения квалификационного класса рекомендующего по отношению к квалификационному классу рекомендуемого.

Обратите внимание, ``GradeLogEntry`` имеет значение для бизнес-требований, и он не может быть усечен снэпшотом event sourced log.
Поэтому, он выполнен в виде самостоятельного Объекта-Значения.
Хотя... он не играет никакой роли в инвариантах ни одного Агрегата, и может быть перемещен в ReadModel.


Реализация требований
^^^^^^^^^^^^^^^^^^^^^

Пройдемся по требованиям:

Каждый член Организации может отдать 20 рекомендаций (признаний) в год в пользу других членов.
    Это требование реализуется счетчиком ``Recognizer.availableEndorsementCount`` и инвариантом ``Объекта-Значения AvailableEndorsementCount``, который не может превышать установленное ограничение.

Одна рекомендация от члена Организации претендуемого (или более высокого) квалификационного класса равноценна двум рекомендациям от членов Организации текущего квалификационного класса (излишки не переносятся).
    Это требование реализуется обработчиком Доменного События ``EndorsementCreated`` перед вызовом метода ``Endorsed.IncreaseReceivedEndorsementCount(Weight)``.

Рекомендации от членов Организации более низкого квалификационного класса не допускаются.
    Реализуется фабричным методом ``Recognizer.Endorse(...)``.

Допускается одна рекомендация рекомендующего за один конкретный артефакт рекомендуемого.
    Это требование обсудим отдельно.

Требуемые количества рекомендаций по квалификационным классам...
    Реализуется фабричным методом ``Recognizer.Endorse(...)``.


Проблемы данной модели
^^^^^^^^^^^^^^^^^^^^^^

В существующей модели прослеживается ряд проблем. Рассмотрим их по порядку.


Вероятность утраты согласованности
""""""""""""""""""""""""""""""""""

Давайте представим, что ``recognizerA`` 2-го класса дает рекомендацию в пользу ``endorsedA`` 2-го класса, у которого уже существует 13 рекомендаций, т.е. до присвоения нового квалификационного класса не хватает всего одной рекомендации.
В период времени с момента проверки инварианта методом ``Recognizer.Endorse(...)`` и до декрементирования счетчика доступных рекомендаций рекомендующего методом ``Recognizer.DecreaseAvailableEndorsementCount()``, а также до вызова метода ``Endorsed.IncreaseReceivedEndorsementCount(Weight)``, другой участник ``recognizerB`` 2-го класса может также успеть дать рекомендацию в пользу ``endorsedA``.

В результате рекомендация ``recognizerB`` будет зачтена в пользу ``endorsedA`` уже фактически 1-го класса, что нарушает требование о запрете на рекомендацию участников более высокого квалификационного класса.

Для упреждения такой ситуации достаточно наложить покрывающий (композитный) уникальный индекс на поля ``Endorsement.endorsedId`` и ``Endorsement.endorsedVersion``.

Или рассмотрим другую ситуацию.
Участник ``recognizerA``, у которого оставалась всего одна доступная рекомендация в текущем году, дает рекомендацию в пользу ``endorsedA``, 
но произошла техническая задержка доставки сообщения ``EndorsementCreated`` рекомендующему по техническим причинам, например, очередь "встала" (или подписчик затупил, чек-поинт в БД запустился...), и тогда рекомендующий может успеть раздать рекомендаций больше, чем располагает.
Упреждается такая ситуация таким же образом - покрывающим уникальным индексом на поля ``Endorsement.recognizerId`` и ``Endorsement.recognizerGrade``.

Но это выдвигает новый вопрос - каким образом партиционировать таблицу ``Endorsement``, чтобы реализовать оба уникальных индекса?
Кто хоть раз занимался партиционированием, тот знает, что уникальный индекс возможен только в пределах партиции.
Можно, конечно, партиционировать ``Endorsement`` по автоинкрементальному первичному ключу (или по дате создания), но тут самое время перейти к следующему требованию, которое гласит: "Допускается одна рекомендация рекомендующего за один конкретный артефакт рекомендуемого".


Уникальность артефакта
""""""""""""""""""""""

Суть в том, что дубликаты описаний артефактов могут быть нечеткими.
Требуется вводить пре-модерацию рекомендаций.
Но это значит, что оптимистическая блокировка с помощью уникального индекса может длиться часами и днями.
Вряд ли пользователи системы будут в восторге от этого.

А что если выделить ``Endorsement.artifactDescription`` в отдельный Агрегат и сделать пре-модерацию для него?
Кажется, это предотвратит длительные блокировки по уже одобренным артефактам, а рекомендация неодобренных артефактов в принципе невозможна.
Более того, артефакты можно категоризировать, и тогда система сможет информировать не только о квалификационной классности члена Организации, но и об областях знаний его экспертности.

Вносим правки:

.. code-block:: go

    type Endorsement struct {
	    recognizerId        RecognizerId
	    recognizerGrade     Grade
	    recognizerVersion   int
	    endorsedId          EndorsedId
	    endorsedGrade       Grade
	    endorsedVersion     int
	    artifactId          ArtifactId
	    createdAt           time.Time
    }

    type Artifact struct {
	    id                  ArtifactId
	    artifactDescription ArtifactDescription
	    status              ArtifactStatus
	    createdAt           time.Time
    }

    type ExpertiseArea struct {
	    id        ExpertiseAreaId
	    name      ExpertiseAreaName
	    createdAt time.Time
    }

Задача упрощается.
В момент создания Агрегата ``Endorsement`` мы можем удостовериться, что такой артефакт такого рекомендуемого не был еще рекомендован таким рекомендующим, с помощью стратегии-валидатора, передаваемой аргументом в фабричный метод, ответственный за создание этого Агрегата.

Но вот в чем дело.
После выделения артефакта в отдельный Агрегат, нам корневой доступ к Агрегату ``Endorsement`` особо-то и не нужен.
Это значит, что его можно преобразовать в Сущность.
С точки зрения `DDD Trilemma <https://enterprisecraftsmanship.com/posts/domain-model-purity-completeness/>`__, учитывая относительно небольшое количество возможных рекомендаций в процессе жизни Агрегата ``Endorsed``, имеет смысл отдать предпочтение в пользу "Domain model purity" и "Domain model completeness".

Вопрос в том, в каком именно Агрегате разместить Сущность ``Endorsement``?
Ответ на этот вопрос подскажет нам то, по какому ключу лучше партиционировать таблицу ``Endorsement``.
Сейчас становится уже очевидно, что партиционирование по автоинкрементальному первичному ключу (или по дате создания) будет приводить к просмотру всех партиций, что нас не устраивает.

У кого хранится в реальном мире наградной лист, почетная грамота, сертификат и т.д. - у награждаемого или у награждающего?
Для кого он имеет ценность?

Это наводит на мысль о том, что Сущность ``Endorsement`` должна принадлежать Агрегату ``Endorsed``.
Что подтвержается также ответом на вопрос о том, должен ли рекомендующий, т.е. Агрегат ``Recognizer``, хранить рекомендации удаленных из системы рекомендуемых?
Вроде бы рекомендации должны удаляться вместе с рекомендуемым (это отвечает и на вопрос о том, по какому ключу партиционировать таблицу ``Endorsement``).
А вот если из системы удаляется рекомендующий, то его рекомендации продолжают иметь значение как способ подтверждения достоверности квалификационной классности рекомендуемого.
Иными словами, квалификационная классность рекомендуемого является `сверткой (left fold) <https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0>`__ этих рекомендаций, по-другому говоря - их проекцией.

Таким образом, между рекомендуемым и рекомендациями образуется строгая согласованность.
Все, что теперь требуется Агрегату ``Endorsed`` для того, чтобы установить возможность создания рекомендации - это квалификационный класс рекомендующего и достоверность того, что он пока еще не исчерпал доступные ему рекомендации.

Но это так же значит, что мы не можем создать покрывающий уникальный индекс на поля ``Endorsement.recognizerId`` и ``Endorsement.recognizerGrade``.

Иными словами, существует незначительная вероятность того, что ``Recognizer`` успеет раздать рекомендаций больше, чем ему доступно.

Существует несколько способов решить эту проблему.

Первый из них - это "`Data, context, and interaction (DCI) <https://en.m.wikipedia.org/wiki/Data,_context_and_interaction>`__".
Подробно он описан в главе "Chapter 9. Coding it Up: The DCI Architecture" книги "Lean Architecture: for Agile Software Development" 1st edition by James O. Coplien, Gertrud Bjørnvig.
Можно посмотреть на `примере <https://github.com/agiledragon/transfer-money-go>`__ реализации перевода денежных средств с одного счета на другой счет (который, в определенной мере, похож на перенос рекомендации от одного члена Организации к другому члену Организации).


Упрощенная реализация итоговой модели
-------------------------------------

.. literalinclude:: _media/aggregate-boundaries/aggregate_boundaries_2.go
   :language: go

Ссылка на полную модель:

- https://github.com/emacsway/qualifying-grade/tree/main/grade/internal/domain


TODO:

- ProcessManager
- PendingEnmersementCount
- CausalConsistency
