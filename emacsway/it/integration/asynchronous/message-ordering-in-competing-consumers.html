
<!DOCTYPE html>

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>О гонке сообщений в условиях конкурирующих подписчиков &#8212; System Architecture</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/translations.js"></script>
    <link rel="index" title="Алфавитный указатель" href="../../../../genindex.html" />
    <link rel="search" title="Поиск" href="../../../../search.html" />
    <link rel="next" title="SDLC" href="../../../../trunk/it/sdlc/index.html" />
    <link rel="prev" title="Asynchronous communication" href="../../../../trunk/it/integration/asynchronous/index.html" />
    
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />



    
        
            <link rel="canonical" href="https://dckms.github.io/system-architecture/emacsway/it/integration/asynchronous/message-ordering-in-competing-consumers.html" />
        
    

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../../../../trunk/it/integration/asynchronous/index.html" title="Previous document">Asynchronous communication</a>
        </li>
        <li>
          <a href="../../../../trunk/it/sdlc/index.html" title="Next document">SDLC</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
    
  <div class="section" id="index-0">
<span id="id1"></span><h1><a class="toc-backref" href="#id7">О гонке сообщений в условиях конкурирующих подписчиков</a><a class="headerlink" href="#index-0" title="Ссылка на этот заголовок">¶</a></h1>
<p><em>Автор раздела: Ivan Zakrevsky</em></p>
<p>Одной из непростых  тем в DDD и микросервисной архитектуре является т.н. <strong>проблема &quot;конкурирующих подписчиков&quot;</strong>. Это когда два причинно-зависимых события попадают на конкурирующие узлы обработки событий, и второе событие может &quot;обогнать&quot; первое, например, по причине того, что при обработке первого события возникли сетевые издержки, или запустился сборщик мусора, или по какой-либо причине первое сообщение не было обработано и подтверждено (ack) с первого раза. Возникает гонка сообщений.</p>
<div class="contents topic" id="id2">
<p class="topic-title">Содержание</p>
<ul class="simple">
<li><p><a class="reference internal" href="#index-0" id="id7">О гонке сообщений в условиях конкурирующих подписчиков</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id8">Поддержка коммутативности</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id9">Исключение причин нарушения очередности событий</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id10">Восстановление очередности сообщений</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id11">Восстановление очередности обработки сообщений</a></p></li>
</ul>
</li>
</ul>
</div>
<p>Например, <a class="reference external" href="https://docs.nats.io/nats-concepts/queue">NATS использует Round-robin для балансировки подписчиков группы</a>, и там эта проблема хорошо проявляется. Партиционирование каналов <a class="reference external" href="https://bravenewgeek.com/building-a-distributed-log-from-scratch-part-5-sketching-a-new-system/">появилось</a> только в пока еще нестабильном <a class="reference external" href="https://github.com/nats-io/jetstream">jetstream</a>.</p>
<p>Кроме того, доставка сообщений может пакетироваться из соображений оптимизации.</p>
<p>Один из примеров, который мне запомнился (с какой-то статьи) - это когда один из пользователей соц.сети удаляет из списка друзей другого пользователя, и тут же шлет оставшимся друзьям письмо, в котором дискредитирует удаленного друга. Возникает два события, первое - на удаление друга, второе - на отправку сообщения списку оставшихся друзей. Причем, второе сообщение находится в причинной зависимости от первого, и должно быть обработано после первого. Возникает гонка событий.</p>
<p>В условиях конкурирующих подписчиков, хронология обработки событий может измениться. И тогда, в момент отправки дискредитирующего письма списку друзей, удаленный пользователь все еще будет присутствовать в списке получателей.</p>
<p>Существует несколько стратегий решения этой проблемы:</p>
<ol class="arabic simple">
<li><p>Нивелировать побочные эффекты (устранить симптомы) от нарушения очередности событий (коммутативность).</p></li>
<li><p>Исключить причины нарушения очередности событий.</p></li>
<li><p>Восстановить очередность сообщений.</p></li>
<li><p>Восстановить очередность обработки сообщений.</p></li>
</ol>
<p>Будем рассматривать каждый из вариантов поочередно в отдельных постах.</p>
<p>А пока - список литературы, который хорошо освещает эту проблему:</p>
<ul class="simple">
<li><p>&quot;Designing Data-Intensive Applications. The Big Ideas Behind Reliable, Scalable, and Maintainable Systems&quot; by Martin Kleppmann</p></li>
<li><p>&quot;<a class="reference external" href="https://martin.kleppmann.com/2020/11/18/distributed-systems-and-elliptic-curves.html">Lecture notes (PDF) (including exercises)</a>&quot; by Martin Kleppman (<a class="reference external" href="https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf">download</a>, <a class="reference external" href="https://github.com/ept/dist-sys">source code</a>, <a class="reference external" href="https://www.youtube.com/playlist?list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB">video</a>)</p></li>
<li><p>&quot;Database Internals: A Deep Dive into How Distributed Data Systems Work&quot; by Alex Petrov</p></li>
<li><p>&quot;Distributed systems: principles and paradigms&quot; 3d edition by Andrew S. Tanenbaum, Maarten Van Steen</p></li>
<li><p>&quot;<a class="reference external" href="http://books.ifmo.ru/file/pdf/1551.pdf">Введение в распределенные вычисления</a>&quot; / Косяков М. С. — СПб: НИУ ИТМО, 2014. — С. 75-82. — 155 с.</p></li>
<li><p>&quot;<a class="reference external" href="http://book.mixu.net/distsys/">Distributed systems: for fun and profit</a>&quot; (2013). An introduction to distributed systems. (<a class="reference external" href="https://github.com/mixu/distsysbook">source code</a>)</p></li>
<li><p>&quot;Database Reliability Engineering. Designing and Operating Resilient Database Systems.&quot; by Laine Campbell and Charity Majors</p></li>
<li><p>&quot;<a class="reference external" href="https://leanpub.com/dddwithpython">Event Sourced Building Blocks for Domain-Driven Design with Python</a>&quot; by John Bywater</p></li>
</ul>
<p>Статьи по теме:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://queue.acm.org/detail.cfm?id=2610533">Don't Settle for Eventual Consistency. Stronger properties for low-latency geo-replicated storage.</a>&quot; (<a class="reference external" href="https://dl.acm.org/ft_gateway.cfm?id=2610533&amp;ftid=1449165&amp;dwn=1">pdf</a>) by Wyatt Lloyd, Facebook; Michael J. Freedman, Princeton University; Michael Kaminsky, Intel Labs; David G. Andersen, Carnegie Mellon University</p></li>
<li><p>&quot;<a class="reference external" href="http://www.bailis.org/papers/bolton-sigmod2013.pdf">Bolt-on Causal Consistency</a>&quot; by Peter Bailis, Ali Ghodsi, Joseph M. Hellerstein†, Ion Stoica, UC Berkeley KTH/Royal Institute of Technology</p></li>
<li><p>&quot;<a class="reference external" href="https://disco.ethz.ch/courses/hs08/seminar/papers/mattern4.pdf">Detecting Causal Relationships in Distributed Computations:In Search of the Holy Grail</a>&quot; by Reinhard Schwarz, Friedemann Mattern</p></li>
<li><p>&quot;<a class="reference external" href="https://www.microsoft.com/en-us/research/publication/principles-of-eventual-consistency/">Principles of Eventual Consistency</a>&quot; (<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/final-printversion-10-5-14.pdf">pdf</a>) by Sebastian Burckhardt, Microsoft Research</p></li>
<li><p>&quot;<a class="reference external" href="https://habr.com/ru/company/ua-hosting/blog/487638/">HighLoad++, Михаил Тюленев (MongoDB): Causal consistency: от теории к практике</a>&quot;</p></li>
<li><p>&quot;<a class="reference external" href="https://martinfowler.com/articles/patterns-of-distributed-systems/version-vector.html">Version Vector</a>&quot; by Unmesh Joshi</p></li>
<li><p>&quot;<a class="reference external" href="https://www.infoq.com/articles/no-reliable-messaging/">Nobody Needs Reliable Messaging</a>&quot; by Marc de Graauw</p></li>
</ul>
<p>Список литературы по интеграционным паттернам:</p>
<ul class="simple">
<li><p>&quot;Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions&quot; by Gregor Hohpe, Bobby Woolf</p></li>
<li><p>&quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; by Vaughn Vernon</p></li>
<li><p>&quot;Camel in Action&quot; 2nd Edition by Claus Ibsen and Jonathan Anstey</p></li>
</ul>
<p>Примеры интеграционных паттернов:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/VaughnVernon/ReactiveMessagingPatterns_ActorModel">https://github.com/VaughnVernon/ReactiveMessagingPatterns_ActorModel</a></p></li>
<li><p><a class="reference external" href="https://camel.apache.org/components/latest/eips/enterprise-integration-patterns.html">https://camel.apache.org/components/latest/eips/enterprise-integration-patterns.html</a></p></li>
<li><p><a class="reference external" href="https://github.com/camelinaction/camelinaction2">https://github.com/camelinaction/camelinaction2</a></p></li>
<li><p><a class="reference external" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/">https://www.enterpriseintegrationpatterns.com/patterns/messaging/</a></p></li>
</ul>
<p>Каталог моделей согласованности:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://jepsen.io/consistency">https://jepsen.io/consistency</a></p></li>
</ul>
<p>Шпаргалка по EIP-паттернам:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/download/EIPTutorialReferenceChart.pdf">Enterprise Integration Patterns Tutorial Reference Chart</a>&quot;</p></li>
</ul>
<p>Каталоги:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">Cloud Design Patterns</a>&quot;</p></li>
<li><p>&quot;<a class="reference external" href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn568099(v=pandp.10)">Cloud Design Patterns. Prescriptive architecture guidance for cloud applications</a>&quot; by Alex Homer, John Sharp, Larry Brader, Masashi Narumoto, Trent Swanson.</p></li>
</ul>
<p>Code Samples:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://aka.ms/cloud-design-patterns-sample">http://aka.ms/cloud-design-patterns-sample</a></p></li>
<li><p>&quot;<a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/">Cloud Best Practices</a>&quot; by Microsoft Corporation and community</p></li>
</ul>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">Поддержка коммутативности</a><a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Первая из перечисленных стратегий решения проблемы &quot;конкурирующих подписчиков&quot; - это &quot;<strong>нивелировать побочные эффекты (устранить симптомы) от нарушения очередности событий (коммутативность)</strong>&quot;.</p>
<p>Часто бывает так, что два действия подряд над одним и тем же агрегатом приводят к тому, что, в условиях конкурирующих подписчиков, сообщение второго события может обогнать сообщение первого события. Если при этом используется &quot;<strong>Event-Carried State Transfer</strong>&quot; ( <a class="reference external" href="https://martinfowler.com/articles/201701-event-driven.html">https://martinfowler.com/articles/201701-event-driven.html</a> ), то при обработке следующего сообщения (которое было отправлено первым), система будет оперировать уже устаревшими данными.</p>
<p>Как один из вариантов решения проблемы в таком случае, может быть переход на &quot;<strong>Event Notification</strong>&quot;. В некоторых случаях прокатывает. Но он ухудшает availability (CAP-Theorem) из-за каскадного синхронного запроса.</p>
<p>В некоторых случаях также прокатывает игнорирование предыдущего события, если последующее событие уже было обработано.</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id9">Исключение причин нарушения очередности событий</a><a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вторая из перечисленных стратегий решения проблемы &quot;конкурирующих подписчиков&quot; - это &quot;<strong>исключить причины нарушения очередности событий</strong>&quot;.</p>
<p>Этому способу решения проблемы посвящена глава &quot;<a class="reference external" href="https://livebook.manning.com/book/microservices-patterns/chapter-3/section-3-3-5?origin=product-toc">3.3.5 Competing receivers and message ordering</a>&quot; книги &quot;Microservices Patterns: With examples in Java&quot; by Chris Richardson</p>
<p>Если mеssaging system не поддерживает партиционирование каналов, то его можно реализовать с помощью паттерна EIP &quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentBasedRouter.html">Content-Based Router</a>&quot;</p>
<p>Например, <a class="reference external" href="https://camel.apache.org/components/latest/eips/content-based-router-eip.html">используя Camel Framework</a>.</p>
<p>С помощью партиционирования каналов мы добиваемся того, что все сообщения одного и того же <strong>причинно-зависимого (causal) потока</strong> попадают на один и тот же узел группы подписчиков. Нет конкуренции - нет проблемы. Здесь вводится новый и достаточно обширный термин &quot;<strong>Causal Consistency</strong>&quot;, имеющий критически важное значение для всех, кто имеет дело с распределенными системами.</p>
<p>Vaughn Vernon в &quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; (RMPwAM) ссылается на следующие две статьи по этому вопросу:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://queue.acm.org/detail.cfm?id=2610533">https://queue.acm.org/detail.cfm?id=2610533</a></p></li>
<li><p><a class="reference external" href="http://www.bailis.org/papers/bolton-sigmod2013.pdf">http://www.bailis.org/papers/bolton-sigmod2013.pdf</a></p></li>
</ul>
<p>Каталог моделей согласованности:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://jepsen.io/consistency">https://jepsen.io/consistency</a></p></li>
</ul>
<p>Было бы, наверное, уместно упомянуть в контексте этого обсуждения пару превосходных материалов на тему CAP-theorem и Consistency:</p>
<p>Самое понятное объяснение CAP-Theorem, которое я когда-либо видел:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="http://ksat.me/a-plain-english-introduction-to-cap-theorem">A plain english introduction to CAP Theorem</a>&quot; by Kaushik Sathupadi (<a class="reference external" href="https://habr.com/ru/post/130577/">перевод на русский</a>)</p></li>
</ul>
<p>Превосходная статья от CTO of Amazon.com Werner Vogels:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html">Eventually Consistent - Revisited</a>&quot;</p></li>
</ul>
<p>Превосходная статья по Causal Consistency (Causal Dependencies) доступным языком:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://habr.com/ru/company/ua-hosting/blog/487638/">HighLoad++, Михаил Тюленев (MongoDB): Causal consistency: от теории к практике</a>&quot;</p></li>
</ul>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id10">Восстановление очередности сообщений</a><a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h2>
<p>Третья из перечисленных стратегий решения проблемы &quot;конкурирующих подписчиков&quot; - это &quot;<strong>восстановить очередность сообщений</strong>&quot;.</p>
<blockquote>
<div><p>📝 &quot;Хьюитт был против включения требований о том, что сообщения должны прибывать в том порядке, в котором они отправлены на модель актора. Если желательно упорядочить входящие сообщения, то это можно смоделировать с помощью очереди акторов, которая обеспечивает такую функциональность. Такие очереди акторов упорядочивали бы поступающие сообщения так, чтобы они были получены в порядке FIFO. В общем же случае, если актор X отправляет сообщение M1 актору Y, а затем тот же актор X отправляет другое сообщение M2 к Y, то не существует никаких требований о том, что M1 придёт к Y раньше M2.&quot;</p>
<p class="attribution">—Pаздел &quot;<a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2#%D0%9D%D0%B8%D0%BA%D0%B0%D0%BA%D0%B8%D1%85_%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9_%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5_%D0%BF%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9">Никаких требований о порядке поступления сообщений</a>&quot; статьи &quot;Модель акторов&quot; Википедии</p>
</div></blockquote>
<p>Для решения этой задачи можно использовать EIP Pattern &quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Resequencer.html">Resequencer</a>&quot;. Например, <a class="reference external" href="https://camel.apache.org/components/latest/eips/resequence-eip.html">используя Camel Framework</a>.</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id11">Восстановление очередности обработки сообщений</a><a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h2>
<p>Четвертая из перечисленных стратегий решения проблемы &quot;конкурирующих подписчиков&quot; - это &quot;<strong>восстановить очередность обработки сообщений</strong>&quot;.</p>
<p>Иными словами, можно пойти другим путем, и отказаться от гарантированной очередности доставки сообщений. Но, в таком случае, подписчик сам должен будет решать, может ли он обработать поступившее сообщение, или же причинно-предшествующее сообщение еще пока не было обработано, и тогда он должен оставить поступившее сообщение в очереди. Правда, на выяснение этого требуется потратить ресурсы (где-то нужно фиксировать обработку сообщений и потом удостоверяться, что предшествующее причинное сообщение уже было обработано).</p>
<p>Как красиво заметил Alexey Zimarev, &quot;мир occasionally-connected устройств по определению не упорядочен&quot;.</p>
<p>Такой подход применяется в Actor Model:</p>
<blockquote>
<div><p>📝 &quot;... модель акторов зеркально отражает систему коммутации пакетов, которая не гарантирует, что пакеты будут получены в порядке отправления. Отсутствие гарантий порядка доставки сообщений позволяет системе коммутации пакетов буферизовать пакеты, использовать несколько путей отправки пакетов, повторно пересылать повреждённые пакеты и использовать другие методы оптимизации.&quot;</p>
<p class="attribution">—Pаздел &quot;<a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2#%D0%9D%D0%B8%D0%BA%D0%B0%D0%BA%D0%B8%D1%85_%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9_%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5_%D0%BF%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9">Никаких требований о порядке поступления сообщений</a>&quot; статьи &quot;Модель акторов&quot; Википедии</p>
</div></blockquote>
<blockquote>
<div><p>📝 &quot;Messages in the Actor model are generalizations of packets in Internet computing in that they need not be received in the order sent. Not implementing the order of delivery, allows packet switching to buffer packets, use multiple paths to send packets, resend damaged packets, and to provide other optimizations.</p>
<p>For example, Actors are allowed to pipeline the processing of messages. What this means is that in the course of processing a message m1, an Actor can designate how to process the next message, and then in fact begin processing another message m2 before it has finished processing m1. Just because an Actor is allowed to pipeline the processing of messages does not mean that it must pipeline the processing. Whether a message is pipelined is an engineering tradeoff.&quot;</p>
<p class="attribution">—&quot;<a class="reference external" href="https://arxiv.org/abs/1008.1459">Actor  Model  of  Computation: Scalable  Robust  Information Systems</a>&quot; by Carl Hewitt</p>
</div></blockquote>
<p>Тут нужно сделать короткое отступление. Хотя, как говорилось ранее, &quot;<em>Хьюитт был против включения требований о том, что сообщения должны прибывать в том порядке, в котором они отправлены на модель актора</em>&quot;, в современных реализациях Actor Model mailbox представлен как FIFO-queue:</p>
<blockquote>
<div><p>📝 &quot;One of the guarantees of the Actor model is sequential message delivery. That is, by default actor mailboxes are first-in, first-out (FIFO) channels. When a message arrives through the actor’s channel, it will be received in the order in which it was sent. Thus, if actor A sends a message to actor B and then actor A sends a second message to actor B, the message that was sent first will be the first message received by actor B.&quot;</p>
</div></blockquote>
<p>Однако, вопрос все-равно остается открытым:</p>
<blockquote>
<div><p>📝 &quot;What if you introduce a third actor, C? Now actor A and actor C both send one or more messages to actor B. There is no guarantee which message actor B will receive first, either the first from actor A or the first from actor C. Nevertheless, the first message from actor A will always be received by actor B before the second message that actor A sends, and the first message from actor C will always
be received by actor B before the second message that actor C sends...</p>
<p>What is implied? Actors must be prepared to accept and reject messages based on their current state, which is reflected by the order in which previous messages were received. Sometimes a latent message could be accepted even if it is not perfect timing, but the actor’s reaction to the latent message may have to carefully take into account its current state beforehand. This may be dealt with more gracefully by using the actors become() capabilities.&quot;</p>
<p class="attribution">—&quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; by Vaughn Vernon, Chapter &quot;5. Messaging Channels :: Point-to-Point Channel&quot;</p>
</div></blockquote>
<p>Кроме того,</p>
<blockquote>
<div><p>📝 &quot;Because individual messages may follow different routes, some messages are likely to pass through the processing steps sooner than others, <strong>resulting in the messages getting out of order</strong>. However, some subsequent processing steps do require in-sequence processing of messages, for example to maintain referential integrity.</p>
<p>One common way things get out of sequence is the fact that different messages may take different processing paths. Let's look at a simple example. Let's assume we are dealing with a numbered sequence of messages. If all even numbered messages have to undergo a special transformation whereas all odd numbered messages can be passed right through, then odd numbered messages will appear on the resulting channel while the even ones queue up at the transformation. If the transformation is quite slow, all odd messages may appear on the output channel before a single even message makes it, bringing the sequence completely out of order.</p>
<p>To avoid getting the messages out of order, we could introduce a loop-back (acknowledgment) mechanism that makes sure that only one message at a time passes through the system. The next message will not be sent until the last one is done processing. This conservative approach will resolve the issue, but has two significant drawbacks. First, it can slow the system significantly. If we have a large number of parallel processing units, we would severely underutilize the processing power. In many instances, the reason for parallel processing is that we need to increase performance, so throttling traffic to one message at a time would complete erase the purpose of the solution. The second issue is that this approach requires us to have control over messages being sent into the processing units. However, often we find ourselves at the receiving end of an out-of-sequence message stream without having control over the message origin.&quot;</p>
<p class="attribution">—&quot;Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions&quot; by Gregor Hohpe, Bobby Woolf</p>
</div></blockquote>
<p>Решение?</p>
<blockquote>
<div><p>📝 &quot;While not discussed in detail here, Message Metadata can be used to achieve causal consistency [<a class="reference external" href="https://queue.acm.org/detail.cfm?id=2610533">AMC-Causal Consistency</a>] among Messages (130) that must be replicated across a network with full ordering preserved [<a class="reference external" href="http://www.bailis.org/papers/bolton-sigmod2013.pdf">Bolt-on Causal Consistency</a>].&quot;</p>
<p class="attribution">—&quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; by Vaughn Vernon, Chapter &quot;10. System Management and Infrastructure :: Message Metadata/History&quot;</p>
</div></blockquote>
<blockquote>
<div><p>📝 &quot;Even so, a technique called causal consistency [<a class="reference external" href="https://queue.acm.org/detail.cfm?id=2610533">AMC-Causal Consistency</a>] can be used to achieve the same.&quot;</p>
<p class="attribution">—&quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; by Vaughn Vernon, Chapter &quot;10. System Management and Infrastructure :: Message Journal/Store&quot;</p>
</div></blockquote>
<blockquote>
<div><p>📝 &quot;To see the full power that results from using Domain Events , consider the concept of causal consistency. A business domain provides causal consistency if its operations that are causally related —one operation causes another—are seen by every dependent node of a distributed system in the same order [<a class="reference external" href="https://queue.acm.org/detail.cfm?id=2610533">Causal</a>] . This means that causally related operations must occur in a specific order, and thus one thing cannot happen unless another thing happens before it. Perhaps this means that one Aggregate cannot be created or modified until it is clear that a specific operation occurred to another
Aggregate.&quot;</p>
<p class="attribution">—&quot;Domain-Driven Design Distilled&quot; by Vaughn Vernon</p>
</div></blockquote>
<p>Посмотреть вживую <a class="reference external" href="https://eventsourcing.readthedocs.io/en/v8.3.0/topics/process.html#causal-dependencies">обеспечение Causal Consistency</a> на уровне подписчика можно в EventSourcing Framework. Реализация <a class="reference external" href="https://github.com/johnbywater/eventsourcing/blob/fd73c5dbd97c0ae759c59f7bb0700afb12db7532/eventsourcing/application/process.py#L273">здесь</a>.</p>
<p>Собственно, Causal является промежуточным уровнем строгости согласованности, чтобы избежать строгую линеаризацию сообщений (которая часто избыточна) из соображений сохранения параллелизма и повышения производительности, но при этом, не допускать параллелизма в потоках причинно-зависимых сообщений (где очередность сообщений, действительно, востребована).</p>
<p>Обычно идентификатором потока (<code class="docutils literal notranslate"><span class="pre">streamId</span></code>) выступает идентификатор агрегата. А идентификатором последовательности события в этом потоке (<code class="docutils literal notranslate"><span class="pre">position</span></code>) обычно <a class="reference external" href="https://github.com/johnbywater/eventsourcing/blob/fd73c5dbd97c0ae759c59f7bb0700afb12db7532/eventsourcing/application/process.py#L82">выступает номер версии агрегата</a></p>
<p>Другой пример кода, реализующего Causal Store можно посмотреть в главе &quot;6.4.2 Causal Store&quot; статьи &quot;<a class="reference external" href="https://www.microsoft.com/en-us/research/publication/principles-of-eventual-consistency/">Principles of Eventual Consistency</a>&quot; (<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/final-printversion-10-5-14.pdf">pdf</a>) by Sebastian Burckhardt, Microsoft Research.</p>
<p>Реализация Vector Clock на Golang - <a class="reference external" href="https://labix.org/vclock">vclock</a>.
Статья об этой библиотеке на сайте автора: &quot;<a class="reference external" href="https://blog.labix.org/2010/12/21/vector-clock-support-for-go">Vector clock support for Go</a>&quot; by Gustavo Niemeyer.</p>
<blockquote>
<div><p>📝 &quot;Note that just <strong>saving the Domain Event in its causal order doesn’t guarantee that it will arrive at other distributed nodes in the same order</strong>. Thus, it is also the responsibility of the consuming Bounded Context to recognize proper <strong>causality</strong>. It might be the Domain Event type itself that can indicate causality, or it may be <strong>metadata</strong> associated with the Domain Event, such as a <strong>sequence</strong> or <strong>causal identifier</strong>. The <strong>sequence</strong> or <strong>causal identifier</strong> would <strong>indicate what caused this Domain Event, and if the cause was not yet seen, the consumer must wait to apply the newly arrived event until its cause arrives</strong>. In some cases it is possible to ignore latent Domain Events that have already been superseded by the actions associated with a later one; in this case causality has a dismissible impact [об этом способе уже говорилось ранее, прим. моё].&quot;</p>
<p class="attribution">—&quot;Domain-Driven Design Distilled&quot; by Vaughn Vernon, Chapter &quot;6. Tactical Design with Domain Events:: Designing, Implementing, and Using Domain Events&quot;</p>
</div></blockquote>
<blockquote>
<div><p>📝 &quot;The first option is to use message sessions, a feature of the Azure Service Bus. If you use <strong>message sessions</strong>, this guarantees that messages within a session are delivered in the same order that they were sent.
The second alternative is to modify the handlers within the application to detect out-of-order messages through the use of sequence numbers or timestamps added to the messages when they are sent. <strong>If the receiving handler detects an out-of-order message, it rejects the message and puts it back onto the queue or topic to be processed later, after it has processed the messages that were sent before the rejected message.</strong>&quot;</p>
<p class="attribution">—&quot;CQRS Journey&quot; by Dominic Betts, Julián Domínguez, Grigori Melnik, Fernando Simonazzi, Mani Subramanian, Chapter &quot;<a class="reference external" href="https://docs.microsoft.com/ru-ru/previous-versions/msp-n-p/jj591565(v=pandp.10)#message-ordering">Journey 6: Versioning Our System :: Message ordering</a>&quot;</p>
</div></blockquote>
<blockquote>
<div><p>📝 &quot;<strong>Actors must be prepared to accept and reject messages based on their current state, which is reflected by the order in which previous messages were received.</strong> Sometimes a latent message could be accepted even if it is not perfect timing, but the actor’s reaction to the latent message may have to carefully take into account its current state beforehand. This may be dealt with more gracefully by using the actors become() capabilities.&quot;</p>
<p class="attribution">—&quot;Reactive Messaging Patterns with the Actor Model: Applications and Integration in Scala and Akka&quot; by Vaughn Vernon, Chapter &quot;5. Messaging Channels :: Point-to-Point Channel&quot;</p>
</div></blockquote>
<p>Возникает вопрос о том, нужно ли заниматься восстановлением очередности сообщений на уровне Domain Logic, или на уровне Application Logic.
В статье &quot;<a class="reference external" href="https://www.infoq.com/articles/no-reliable-messaging/">Nobody Needs Reliable Messaging</a>&quot; by Marc de Graauw приводятся убедительные аргументы о том, что если это важно для бизнеса, то это должно быть на уровне бизнес-логики (Domain Logic).
Однако, нужно учитывать, что термина &quot;Сообщение&quot; в предметной области вообще не существует (есть только &quot;Событие&quot;).
Зато существует термин &quot;время&quot;, которое едино для всего в предметной области, в отличии от времени приложения в распределенной системе.</p>
<p>Таким образом, очередность доставки сообщений - это проблема, свойственная не предметной области, а приложению.
Нужно ли решать её на уровне бизнеса?
Ответ зависит от конкретных обстоятельств.</p>
<p>Еще один из способов решения проблемы согласованности - это дублирование данных, сохранение, обработка и передача зависимых данных атомарно.
Этот прием часто используется для обеспечения границ согласованности Aggregate в DDD, для обеспечения автономности микросервисов и Bounded Contexts.</p>
<blockquote>
<div><p>An implementation consistent with this model would guarantee the invariant relating PO [Purchase Order] and its items, while changes to the price of a part would not have to immediately affect the items that reference it.
Broader consistency rules could be addressed in other ways.
For example, the system could present a queue of items with outdated prices to the users each day, so they could update or exempt each one.
But this is not an invariant that must be enforced at all times.
By making the dependency of line items on parts looser, we avoid contention and reflect the realities of the business better.
At the same time, tightening the relationship of the PO and its line items guarantees that an important business rule will be followed.</p>
<p class="attribution">—&quot;Domain-Driven Design&quot; by Eric Evans</p>
</div></blockquote>
<p>Родственные EIP patterns:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html">Correlation Identifier</a>&quot;</p></li>
<li><p>&quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageSequence.html">Message Sequence</a>&quot;</p></li>
</ul>
<p>Применяется в том числе и в Event Sourcing.</p>
<p>В  метаданных eventstore есть переменные <code class="docutils literal notranslate"><span class="pre">$causationid</span></code> and <code class="docutils literal notranslate"><span class="pre">$correlationid</span></code>.</p>
<blockquote>
<div><p>📝 &quot;The are both really simple patterns I have never quite understood why they end up so misunderstood.
Let's say every message has 3 ids. 1 is its id. Another is correlation the last it causation.
The rules are quite simple. If you are responding to a message, you copy its correlation id as your correlation id, its message id is your causation id.
This allows you to see an entire conversation (correlation id) or to see what causes what (causation id).
Cheers,
Greg Young&quot;</p>
<p><a class="reference external" href="https://discuss.eventstore.com/t/causation-or-correlation-id/828/4">https://discuss.eventstore.com/t/causation-or-correlation-id/828/4</a></p>
</div></blockquote>
<p>Примеры:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/microsoftarchive/cqrs-journey/blob/6ffd9a8c8e865a9f8209552c52fa793fbd496d1f/scripts/CreateDatabaseObjects.sql#L57-L62">раз</a></p></li>
<li><p><a class="reference external" href="https://github.com/kgrzybek/modular-monolith-with-ddd/blob/4e2d66d16f97b3c863fbecd072dad52338516882/src/Modules/Payments/Infrastructure/AggregateStore/SqlStreamAggregateStore.cs#L44-L45">два</a></p></li>
</ul>
<p>Шпаргалка по EIP-паттернам:</p>
<ul class="simple">
<li><p>&quot;<a class="reference external" href="https://www.enterpriseintegrationpatterns.com/download/EIPTutorialReferenceChart.pdf">Enterprise Integration Patterns Tutorial Reference Chart</a>&quot;</p></li>
</ul>
<p>Но даже если подписчик всего один, и сообщения доставляются последовательно, то и тогда очередность обработки сообщений может быть нарушена. Пример из NATS Streaming Server:</p>
<blockquote>
<div><p>📝 &quot;With the redelivery feature, order can’t be guaranteed, since by definition server will resend messages that have not been acknowledged after a period of time. Suppose your consumer receives messages 1, 2 and 3, does not acknowledge 2. Then message 4 is produced, server sends this message to the consumer. The redelivery timer then kicks in and server will resend message 2. The consumer would see messages: 1, 2, 3, 4, 2, 5, etc...</p>
<p>In conclusion, the server does not offer this guarantee although it tries to redeliver messages first thing on startup. That being said, if the durable is stalled (number of outstanding messages &gt;= MaxInflight), then the redelivery will also be stalled, and new messages will be allowed to be sent. When the consumer resumes acking messages, then it may receive redelivered and new messages interleaved (new messages will be in order though).&quot;</p>
<p class="attribution">—nats-streaming-server, <a class="reference external" href="https://github.com/nats-io/nats-streaming-server/issues/187#issuecomment-257024506">issue #187 &quot;Order of delivery&quot;</a>, comment by Ivan Kozlovic</p>
</div></blockquote>
<p>Кстати, проблема очередности доставки сообщений хорошо описана в главе &quot;Projections and Queries :: Building read models from events :: Subscriptions&quot; книги &quot;<a class="reference external" href="https://www.amazon.com/Hands-Domain-Driven-Design-NET-ebook/dp/B07C5WSR9B">Hands-On Domain-Driven Design with .NET Core: Tackling complexity in the heart of software by putting DDD principles into practice</a>&quot; by Alexey Zimarev. И он добавил несколько <a class="reference external" href="https://t.me/emacsway_chat/85">интересных аргументов в чат канала</a>.</p>
</div>
</div>



    
        
            <div class="section" style="text-align: right;">
                <p><a href="https://dckms.github.io/system-architecture/emacsway/it/integration/asynchronous/message-ordering-in-competing-consumers.html">Canonical URL</a></p>
            </div>
        
    

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../../../../trunk/it/integration/asynchronous/index.html" title="Previous document">Asynchronous communication</a>
        </li>
        <li>
          <a href="../../../../trunk/it/sdlc/index.html" title="Next document">SDLC</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">System Architecture</a></h1>



<p class="blurb">Distributed Collaborative Knowledge Management System for System Architecture</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=dckms&repo=system-architecture&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Навигация</h3>
<p class="caption"><span class="caption-text">Общее пространство:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../../trunk/it/index.html">IT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../trunk/soft-skills/index.html">Soft Skills</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../trunk/index.html">Общее пространство</a></li>
</ul>
<p class="caption"><span class="caption-text">Авторские пространства:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Пространство Emacsway</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ivan.ivanov/index.html">Пространство Ивана Иванова</a></li>
</ul>
<p class="caption"><span class="caption-text">Приватное пространствo:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../private/index.html">Приватное пространство</a></li>
</ul>
<p class="caption"><span class="caption-text">Прочее:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../README.html">Как пользоваться</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../trunk/it/index.html">IT</a><ul>
  <li><a href="../../../../trunk/it/integration/index.html">Integration</a><ul>
  <li><a href="../../../../trunk/it/integration/asynchronous/index.html">Asynchronous communication</a><ul>
      <li>Previous: <a href="../../../../trunk/it/integration/asynchronous/index.html" title="предыдущая глава">Asynchronous communication</a></li>
      <li>Next: <a href="../../../../trunk/it/sdlc/index.html" title="следующая глава">SDLC</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Быстрый поиск</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Искать" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    
    <div class="footer">
      &copy;2022, @dckms (<a href="https://dckms.github.io/system-architecture/LICENSE" rel="nofollow">License</a>).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../../_sources/emacsway/it/integration/asynchronous/message-ordering-in-competing-consumers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/dckms/system-architecture" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    

    
        <!-- Yandex.Metrika counter -->
        <script type="text/javascript" >
           (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
           m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
           (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

           ym(87033138, "init", {
                clickmap:true,
                trackLinks:true,
                accurateTrackBounce:true,
                webvisor:true,
                trackHash:true
           });
        </script>
        <noscript><div><img src="https://mc.yandex.ru/watch/87033138" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
        <!-- /Yandex.Metrika counter -->
    

  </body>
</html>